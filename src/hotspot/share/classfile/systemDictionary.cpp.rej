@@ -907,6 +908,7 @@
     ClassLoaderData* loader_data = k->class_loader_data();
     MutexLocker mu(SystemDictionary_lock, THREAD);
     Klass* kk = find_class(name, loader_data);
+    // FIXME: (kk == k() && !k->is_redefining()) || (k->is_redefining() && kk == k->old_version())
     assert(kk == k(), "should be present in dictionary");
   }
 #endif
@@ -1052,6 +1054,7 @@
                                                            protection_domain,
                                                            host_klass,
                                                            cp_patches,
+                                                           false, // pick_newest
                                                            CHECK_NULL);
 
   if (host_klass != NULL && k.not_null()) {
@@ -1100,7 +1103,9 @@
                                              Handle class_loader,
                                              Handle protection_domain,
                                              ClassFileStream* st,
+                                             instanceKlassHandle old_klass,
                                              TRAPS) {
+  bool is_redefining = !old_klass.is_null();
 
   // Classloaders that support parallelism, e.g. bootstrap classloader,
   // or all classloaders with UnsyncloadClass do not acquire lock here
@@ -1127,6 +1132,7 @@
  instanceKlassHandle k;
 
 #if INCLUDE_CDS
+  // FIXME: what to do during redefinition?
   k = SystemDictionaryShared::lookup_from_stream(class_name,
                                                  class_loader,
                                                  protection_domain,
@@ -1144,9 +1150,15 @@
                                          protection_domain,
                                          NULL, // host_klass
                                          NULL, // cp_patches
+                                         is_redefining, // pick_newest
                                          CHECK_NULL);
   }
 
+  if (is_redefining && !k.is_null()) {
+    k->set_redefining(true);
+    k->set_old_version(old_klass());
+  }
+
   assert(k.not_null(), "no klass created");
   Symbol* h_name = k->name();
   assert(class_name == NULL || class_name == h_name, "name mismatch");
@@ -1154,7 +1166,7 @@
   // Add class just loaded
   // If a class loader supports parallel classloading handle parallel define requests
   // find_or_define_instance_class may return a different InstanceKlass
-  if (is_parallelCapable(class_loader)) {
+  if (is_parallelCapable(class_loader) && !is_redefining) {
     instanceKlassHandle defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
     if (!HAS_PENDING_EXCEPTION && defined_k() != k()) {
       // If a parallel capable class loader already defined this class, register 'k' for cleanup.
@@ -1178,7 +1190,7 @@
     MutexLocker mu(SystemDictionary_lock, THREAD);
 
     Klass* check = find_class(h_name, k->class_loader_data());
-    assert(check == k(), "should be present in the dictionary");
+    assert((check == k() && !k->is_redefining()) || (k->is_redefining() && check == k->old_version()), "should be present in the dictionary");
   } );
 
   return k();
@@ -1611,10 +1623,11 @@
   }
 }
 
-void SystemDictionary::define_instance_class(instanceKlassHandle k, TRAPS) {
+void SystemDictionary::define_instance_class(instanceKlassHandle k, instanceKlassHandle old_klass, TRAPS) {
 
   ClassLoaderData* loader_data = k->class_loader_data();
   Handle class_loader_h(THREAD, loader_data->class_loader());
+  bool is_redefining = !old_klass.is_null();
 
  // for bootstrap and other parallel classloaders don't acquire lock,
  // use placeholder token
@@ -1639,7 +1652,11 @@
   Symbol*  name_h = k->name();
   unsigned int d_hash = dictionary()->compute_hash(name_h, loader_data);
   int d_index = dictionary()->hash_to_index(d_hash);
-  check_constraints(d_index, d_hash, k, class_loader_h, true, CHECK);
+  if (is_redefining) {
+    bool ok = dictionary()->update_klass(d_index, d_hash, name_h, loader_data, k, old_klass);
+    assert (ok, "must have found old class and updated!");
+  }
+  check_constraints(d_index, d_hash, k, class_loader_h, !is_redefining, CHECK);
 
   // Register class just loaded with class loader (placed in Vector)
   // Note we do this before updating the dictionary, as this can
@@ -2016,6 +2049,10 @@
   dictionary()->classes_do(f);
 }
 
+void SystemDictionary::classes_do(KlassClosure* closure) {
+  dictionary()->classes_do(closure);
+}
+
 // Added for initialize_itable_for_klass
 //   Just the classes from defining class loaders
 // Don't iterate over placeholders
@@ -2249,7 +2286,7 @@
       // also holds array classes
 
       assert(check->is_instance_klass(), "noninstance in systemdictionary");
-      if ((defining == true) || (k() != check)) {
+      if ((defining == true) || ((k() != check) && k->old_version() != check)) {
         linkage_error1 = "loader (instance of  ";
         linkage_error2 = "): attempted  duplicate class definition for name: \"";
       } else {
